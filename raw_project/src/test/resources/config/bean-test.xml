<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
						http://www.springframework.org/schema/beans/spring-beans.xsd
						http://www.springframework.org/schema/context
                        http://www.springframework.org/schema/context/spring-context.xsd">

  <!--  创建bean的三种方式 -->
  <!--
    第一种方式: 使用默认构造函数创建.
    在spring的配置文件中使用bean标签, 配以id和class属性之后, 且没有其他属性和标签时.
    采用的就是默认构造函数创建bean对象. 此时如果类中没有默认构造函数, 则对象无法创建.
  -->
  <bean id="person1" class="debug.pojo.PersonTest" />

  <!-- 第二种方式: 使用普通工厂中的方法创建对象(使用某个类中的方法创建对象, 并存入spring容器) -->
  <bean id="instanceFactory" class="debug.factory.InstanceFactoryTest" />
  <bean id="person2" factory-bean="instanceFactory" factory-method="getPerson" />

  <!-- 第三种方式: 使用工厂中的静态方法创建对象(使用某个类中的静态方法创建对象, 并存入spring容器) -->
  <bean id="person3" class="debug.factory.StaticFactoryTest" factory-method="getPerson" />

  <!--
    bean的作用范围调整
      bean标签的scope属性:
        作用: 用于指定bean的作用范围
        取值: 常用的事单例和多例的
          singleton: 单例的(默认值)
          prototype: 多例的
          request: 作用于web应用的请求范围
          session: 作用于web应用的会话范围
          global-session: 作用于集群环境的会话范围(全局会话范围), 当不是集群环境时, 它就是session
   -->
  <bean id="person4" class="debug.pojo.PersonTest" scope="prototype" />

  <!--
    bean对象的生命周期
      单例对象
        出生: 当容器创建时对象出生
        或者: 只要容器还在, 对象一直活着
        死亡: 容器销毁, 对象消亡
        总结: 单例对象的生命周期和容器相同
      多例对象
        出生: 当使用对象时spring框架创建
        活着: 对象只要是在使用过程中就一直活着
        死亡: 当对象长时间不用, 且没有别的对象引用时, 由Java的垃圾回收器回收
  -->
  <bean id="person5" class="debug.pojo.PersonTest" scope="singleton" init-method="init" destroy-method="destroy" />
  <bean id="person6" class="debug.pojo.PersonTest" scope="prototype" init-method="init" destroy-method="destroy" />

  <!--
    spring中的依赖注入
      依赖注入:
        Dependency Injection
      IOC的作用:
        降低程序间的耦合(依赖关系)
      依赖关系的管理:
        以后都交给spring来维护
      在当前类需要用到其他类的对象, 由spring为我们提供, 我们只需要在配置文件中说明
      依赖关系的维护:
        就称之为依赖注入.
      依赖注入:
        能注入的数据: 有三类
            基本数据类型和String
            其他bean类型(在配置文件中或者注解配置过的bean)
            复杂类型/集合类型
        注入的方式: 有三种
            第一种: 使用构造函数提供
            第二种: 使用set方法提供
            第三种: 使用注解提供
  -->
  <!--
    构造函数注入:
      使用的标签: constructor-arg
      标签出现的位置: bean标签的内部
    标签中的属性:
      type: 用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型
      index: 用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始
      name: 用于指定给构造函数中指定名称的参数赋值[常用的]
      ==========以上三个用于指定给构造函数中哪个参数赋值========================
      value: 用于提供基本类型和String类型的数据
      ref:用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象
    优势:
      在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。
    弊端:
      改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。
  -->
  <bean id="person7" class="debug.pojo.PersonTest">
    <constructor-arg name="name" value="stone" />
    <constructor-arg name="age" value="29" />
    <constructor-arg name="birthday" ref="now" />
  </bean>

  <bean id="now" class="java.util.Date" />

  <!-- set方法往入 更常用的方式
    涉及的标签: property
    出现的位置: bean标签的内部
    标签的属性
      name: 用于指定注入时所调用的set方法名称
      value: 用于提供基本类型和String类型的数据
      ref: 用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象
    优势:
      创建对象时没有明确的限制，可以直接使用默认构造函数
    弊端:
      如果有某个成员必须有值，则获取对象是有可能set方法没有执行。
  -->
  <bean id="person8" class="debug.pojo.PersonTest">
    <property name="name" value="cindy" />
    <property name="age" value="21" />
    <property name="birthday" ref="now" />
  </bean>

  <!--红杂类型的注入/集合类型的注入
    用于给List结构集合注，入的标签:
      list array set
    用于个Map结构集合注入的标签:
      map props
    结构相同，标签可以互换
  -->
  <bean id="person9" class="debug.pojo.PersonTest">
    <property name="hobbies">
      <array>
        <value>football</value>
        <value>baseball</value>
        <value>basketball</value>
      </array>
    </property>

    <property name="friends">
      <list>
        <value>john</value>
        <value>cindy</value>
      </list>
    </property>

    <property name="strings">
      <set>
        <value>江户川柯南"</value>
        <value>工藤新一"</value>
        <value>毛利兰"</value>
      </set>
    </property>

    <property name="map">
      <map>
        <entry key="username" value="stone" />
        <entry key="country">
          <value>China</value>
        </entry>
      </map>
    </property>

    <property name="properties">
      <props>
        <prop key="email">
          testman00@163.com
        </prop>
      </props>
    </property>
  </bean>
</beans>